<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="theme-color"
      media="(prefers-color-scheme: light)"
      content="#f2f6ff"
    />
    <meta
      name="theme-color"
      media="(prefers-color-scheme: dark)"
      content="#2B2830"
    />
    <title>Actividad Sesión 1</title>
    <link rel="stylesheet" href="../../styles.css" />
    <link rel="stylesheet" href="../../prism.css" />
  </head>

  <body>
    <div class="container">
      <div class="section">
        <a class="back-button" href="/activity/activity.html"> < Back</a>
        <h1>Actividad 1</h1>
        <p class="caption">Actividades Sesión Principiante</p>
        <hr class="separator" />

        <h2 id="ejercicio-1">Ejercicio 1</h2>
        <ul>
          <li>
            Crea un
            <a href="https://github.com/lucferbux/JavaScript-Course"
              >nuevo fork del proyecto del curso</a
            >
          </li>
          <li>Crea un nuevo archivo llamado <code>aboutme.js</code></li>
          <li>
            Crea un script en ese fichero con tres variables (elige un nombre
            descriptivo para cada una). La primera almacenará tu nombre y
            apellidos, la segunda tu profesión y la tercera el puesto que
            querrías desempeñar o el que desempeñas actualmente.
          </li>
          <li>
            Crea una nueva variable que almacene una cadena, que mediante
            <a
              href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"
              >template literals</a
            >
            incluya esta frase con las variables:
            <code
              >Hola, me llamo [variable del nombre] y me dedico a [variable
              profresión]. Estoy cursando este Máster porque me gustaría
              trabajar en [variable del puesto]</code
            >
          </li>
          <li>Muestra por pantalla esta última variable.</li>
          <li>
            Importa tu fichero <code>aboutme.js</code> en el fichero
            <code>index.js</code> en la parte del Ejercicio 1 antes del
            <code>console.log(&quot;Ej 1&quot;)</code>.
          </li>
        </ul>
        <h2 id="ejercicio-2">Ejercicio 2</h2>
        <p>Se requiere un navegador con herramientas de desarrollador:</p>
        <ul>
          <li>
            Abre el navegador seleccionado y dirígete a la sección de
            <code>Actividades/Actividad 1</code>.
          </li>
          <li>
            Abre la sección de <em>Sources</em> en las herramientas web,
            dirígete al fichero aboutme.js que creaste en la sección anterior y
            añade unos cuantos breakpoints en el script que has creado.
          </li>
          <li>Añade un breakpoint más en <code>console.log(“Ej 1”)</code>.</li>
          <li>
            ¿Qué se ejecuta antes, la llamada a <code>console.log()</code> o el
            contenido del fichero <code>aboutme.js</code>? ¿Por qué?
          </li>
          <ul>
            <li>
              El contenido del fichero aboutme.js se ejecuta primero, ya que el
              orden de ejecución suele seguir la secuencia en la que se
              encuentran las líneas de código en el archivo y el flujo de
              ejecución natural del programa, en este caso el import del fichero
              estaba primero que el console.log.
            </li>
          </ul>
        </ul>

        <img src="../../img-ej1/breakpoint1.png" alt="breakpoint1" />
        <img src="../../img-ej1/breakpoint2.png" alt="breakpoint2" />
        <img src="../../img-ej1/resultado.png" alt="resultado" />

        <pre>
<code class="language-javascript">// Ejercicio 1

console.log("Ejercicio 1");

// Ejercicio 2

// Ejercicio 3

// Ejercicio 4

// Ejercicio 5

// Ejercicio 6</code></pre>

        <h2 id="ejercicio-3">Ejercicio 3</h2>
        <ul>
          <li>
            Programa un script que imprima todos los números del 1 al 100 que
            sean divisibles por 7.
          </li>
        </ul>
        <h2 id="ejercicio-4">Ejercicio 4</h2>
        <ul>
          <li>
            Siguiendo el ejemplo anterior, imagina que has usado un bucle como
            este:
          </li>
        </ul>
        <pre><code class="lang-javascript"><span class="hljs-keyword">for</span>(var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-number">101</span>; <span class="hljs-built_in">i</span>++) {
    // Solución
}
console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">i</span>);
</code></pre>
        <ul>
          <li>
            ¿Qué valor tendrá la variable <code>i</code> al finalizar el bucle?
            ¿Por qué? ¿Habría alguna forma de evitar que la variable
            <code>i</code> se declare de forma global?
          </li>
          <ul>
            <li>
              101, Por que es una variable global ya que usamos var para
              declararla
            </li>
            <li>
              Usando 'let' en vez de 'var' para declararla. Al utilizar let, i
              ya no sería accesible fuera del bucle y el intento de imprimir i
              después del bucle resultaría en un error de referencia (i is not
              defined).
            </li>
          </ul>
        </ul>
        <h2 id="ejercicio-5">Ejercicio 5</h2>
        <ul>
          <li>
            ¿Cuáles son las diferencias entre ejecutar un fichero JavaScript en
            un navegador web en formato <code>&lt;script&gt;</code> y en formato
            <code>&lt;script type=”module”&gt;</code>?. Busca documentación para
            enumerar los principales comportamientos de ambas.
          </li>
          <ul>
            <li>
              <code>&lt;script&gt;</code> (sin tipo especificado o con
              <code>type="text/javascript"</code>)
            </li>
            <ul>
              <li>
                Carga Sincrónica: Los scripts se cargan y ejecutan de manera
                síncrona. Esto significa que si hay varios scripts, el navegador
                los ejecutará en el orden en que se encuentran en el HTML, y el
                procesamiento de la página se detiene hasta que se complete la
                ejecución del script.
              </li>
              <li>
                Ámbito Global: Las variables y funciones declaradas en un script
                cargado con <code>&lt;script&gt;</code> se añaden al ámbito
                global (a menos que se utilicen estrategias específicas para
                evitarlo), lo que puede provocar posibles conflictos entre
                variables con el mismo nombre en diferentes scripts.
              </li>
              <li>
                No hay importaciones/exportaciones: No admite las declaraciones
                import y export de ES6 para importar o exportar módulos. Esto
                significa que no se pueden usar módulos ECMAScript nativos, lo
                que limita la modularidad y reutilización de código.
              </li>
            </ul>

            <li><code>&lt;script type="module&gt;</code></li>
            <ul>
              <li>
                Carga Asincrónica: Los scripts tipo módulo (<code
                  >&lt;script type="module"&gt;</code
                >) se cargan de manera asincrónica por defecto. Esto permite que
                la página continúe cargándose mientras los módulos se descargan
                en segundo plano.
              </li>
              <li>
                Ámbito de Módulo: Los módulos tienen su propio ámbito y no
                añaden variables o funciones al ámbito global por defecto. Esto
                ayuda a evitar colisiones de nombres y a mantener la
                encapsulación del código.
              </li>
              <li>
                Importaciones/Exportaciones: Admite las declaraciones import y
                export de ES6 para importar y exportar módulos. Esto facilita la
                modularidad y reutilización del código, permitiendo la
                estructuración y organización del código en módulos
                independientes.
              </li>
              <li>
                Política de CORS: Los scripts de módulos tienen una política de
                CORS más estricta en comparación con los scripts tradicionales.
                Los navegadores pueden rechazar la carga de módulos desde
                orígenes no permitidos por la política de CORS.
              </li>
            </ul>
          </ul>
        </ul>
        <h2 id="ejercicio-6">Ejercicio 6</h2>
        <ul>
          <li>
            Crea un objeto llamado <strong>formatter</strong> con un atributo,
            que llamaremos <em>prefix</em>, que tendrá de valor
            <code>“Hello “</code>, y un método que llamaremos <em>append</em>,
            que imprimirá la concatenación entre el atributo <em>prefix</em> y
            la cadena que pasemos como argumento en el método.
          </li>
        </ul>
        <p><code>formatter.append(“World”) // Result: Hello World</code></p>
        <ul>
          <li>
            <strong>Una vez el objeto esté creado</strong> añade mediante el
            atributo <strong>prototype</strong> (buscad en la documentación)
            otro método que acepte también un solo argumento e imprima esa misma
            cadena en minúsculas.
          </li>
        </ul>
        <p>
          <code>formatter.toLowerString(“I’m Lucas”) // Result: i’m lucas</code>
        </p>
      </div>
    </div>
    <script src="../../prism.js"></script>
    <script type="module" src="index.js"></script>
  </body>
</html>
